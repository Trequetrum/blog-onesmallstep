<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>One Small Step - Types</title>
    <subtitle>Now let it work. Mischief, thou art afoot, Take thou what course thou wilt!</subtitle>
    <link href="https://trequetrum.github.io/blog-onesmallstep/categories/types/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://trequetrum.github.io/blog-onesmallstep"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-06-09T00:00:00+00:00</updated>
    <id>https://trequetrum.github.io/blog-onesmallstep/categories/types/atom.xml</id>
    <entry xml:lang="en">
        <title>What&#x27;s a Type?</title>
        <published>2023-06-09T00:00:00+00:00</published>
        <updated>2023-06-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://trequetrum.github.io/blog-onesmallstep/what-is-a-type/" type="text/html"/>
        <id>https://trequetrum.github.io/blog-onesmallstep/what-is-a-type/</id>
        
        <content type="html">&lt;p&gt;This is the first in a series of loosely related posts exploring Types, Type Theory, Type Systems, and some related content from the point of view of a computer scientist. The general idea is to provide a &lt;span class=pink-emph&gt;10000 foot view&lt;&#x2F;span&gt; of what I&#x27;ve been learning on the topic that may inspire me (or others) to remember and learn more. &lt;&#x2F;p&gt;
&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;&#x2F;h1&gt;
&lt;p&gt;Soooooooo... what is a type?&lt;&#x2F;p&gt;
&lt;p&gt;The question this blog post is trying to answer can feel rather nebulous. The problem is that in programming languages, types wear many hats. Function overloading lets you create control flow based on types, deriving mechanisms let you generate code based on types, IDEs provide some of their tooling based on type definitions, and so forth.&lt;&#x2F;p&gt;
&lt;p&gt;My plan here is to dance around the topic a bit. I want to talk about the basic types most programmers are familiar with — for example, integers. I also want to motivate future discussions in other posts about types that are a bit more abstract. For example, types that construct other types, or types that form a mathematical structure called a semiring — which among other things let you use algebra to get nice things for free.&lt;&#x2F;p&gt;
&lt;p&gt;One of the things I&#x27;ve hoped to avoid doing here is to mystify types (I&#x27;m not sure whether I&#x27;ve succeeded). While types seem to get at the fundamentals of what abstraction is about, they&#x27;re also very natural. Assembly programmers have been using types since before we developed syntax for them or automated ways to enforce&#x2F;check them. What I&#x27;m trying to dance around here really shouldn&#x27;t invalidate anything about the types you are already familiar with. Nobody has lied to you about &lt;span class=blue-emph&gt;Booleans&lt;&#x2F;span&gt; or &lt;span class=blue-emph&gt;Strings&lt;&#x2F;span&gt;, they continue to be what you&#x27;ve always known. &lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;re going to start with what I undertand the general pragmatic view of types to be, then I&#x27;m going to detour us into some super basic Propositional Logic and hopefully come full circle into a very vague understanding of types and how we might change our view on what it means to annotate a program with them.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-pragmatic-view-of-types-in-computer-science&quot;&gt;The Pragmatic View of Types in Computer Science&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;[A] computer is unable to discriminate between for example a memory address and an instruction code, or between a character, an integer, or a floating-point number, because it makes no intrinsic distinction between any of the possible values that a sequence of bits might &lt;em&gt;mean&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;[...]&lt;&#x2F;p&gt;
&lt;p&gt;Assigning a data type, termed typing, gives &lt;em&gt;meaning&lt;&#x2F;em&gt; to a sequence of bits such as a value in memory&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_system&quot;&gt;Wikipedia &lt;sup&gt;(link)&lt;&#x2F;sup&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Consider the following sequence of bits:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;10000001
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What could this sequence of bits represent as a value?&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If that&#x27;s an unsigned 8bit integer, then it could represent a &lt;code&gt;129&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;It also could represent any constant transformation of an 8bit integer:
&lt;ul&gt;
&lt;li&gt;Absolute negative value: &lt;code&gt;-129&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Thousands: &lt;code&gt;129,000&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Even numbers: &lt;code&gt;258&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;If that&#x27;s a signed 8bit integer:
&lt;ul&gt;
&lt;li&gt;It could represent a &lt;code&gt;-1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;If it is in 2s complement then &lt;code&gt;-127&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;If the bit that carries the sign isn&#x27;t the standard one, there&#x27;s a whole other set of numbers this could represent.&lt;&#x2F;li&gt;
&lt;li&gt;It could be an array of two unsigned 4bit integers: &lt;code&gt;[8,1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;The value may not be an integer at all. Getting more outlandish, it might be a bit-map for items in an adventurer&#x27;s backpack. In which case this might encode two specific key items (item-id &lt;code&gt;0&lt;&#x2F;code&gt; and &lt;code&gt;7&lt;&#x2F;code&gt;) out of eight key items an adventurer will need to find during their quest! &lt;&#x2F;li&gt;
&lt;li&gt;This value could be a memory address on a &lt;strong&gt;very&lt;&#x2F;strong&gt; small embedded system, or perhaps the system pads this with zeros to interpret it as a memory address.&lt;&#x2F;li&gt;
&lt;li&gt;This could be a machine instruction code of some sort.&lt;&#x2F;li&gt;
&lt;li&gt;This could be a path through a binary tree.&lt;&#x2F;li&gt;
&lt;li&gt;The above considerations also depend on the &amp;quot;endianness&amp;quot; of the memory layout as well.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;You can see the problem. You cannot tell the type of this value by inspecting its bits. Giving those bits a type is the process by which we imbue them with meaning. It doesn&#x27;t matter that assembly has no means to annotate types and no automated way to check them, any programmer using assembly must do that work manually — they can not reasonably choose to avoid it. For example: it&#x27;s never desirable to multiply two memory addresses together, so an assembly programmer does their best to avoid doing so. Failing in this task isn&#x27;t a type error within the language, but it is still a type error conceptually and will result in an incorrect program.&lt;&#x2F;p&gt;
&lt;p&gt;Programmers need to reason about the types of the data they are working with in order to ensure that their programs are correct.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-more-abstract-view-of-types&quot;&gt;A more abstract view of types&lt;&#x2F;h1&gt;
&lt;p&gt;The pragmatic view of types really bundles up the idea of capturing how data is represented. This is not typically how types act while programming. Consider how often a developer even sees the sequence of bits that represent the values they use. Especially in the basic nominal cases, developers leave the bit-fiddling to low-level operations. It really doeasn&#x27;t matter if a &lt;code&gt;-5&lt;&#x2F;code&gt; looks like &lt;code&gt;1000 0101&lt;&#x2F;code&gt; or &lt;code&gt;1111 1011&lt;&#x2F;code&gt;, so long as the operations (like addition and so on) work as expected.&lt;&#x2F;p&gt;
&lt;p&gt;In general, programmers consider even the most fundamental types to have an existential representation. A well behaved representation exists (because it must), but any other well behaved representation would do just as well. The type system forms an abstraction boundary so that so long as the API of an &lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt; doesn&#x27;t change, the representation is largely irrelevant &lt;sup&gt;[1]&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of &amp;quot;giving meaning&amp;quot; to a sequence of bits, types can be seen in some ways as the opposite. They describe a program that&#x27;s provably generic over the representation, which means a Java Class doesn&#x27;t describe a program, but instead a whole set of programs (at least one program for each possible representation of &lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt;). It just so happens we pick binary representations that work well with our hardware.&lt;&#x2F;p&gt;
&lt;p&gt;In some languages there are pragmatic reasons (say performance&#x2F;memory) to care about the representation or some part of the representation. Because of its pedigree as a systems language, Rust has 12 different integer types, though they differ on whether they are signed (support negative integers) and how much memory they require, they don&#x27;t differ on any other representational decisions such as which bit is the most significant, which bit is signed, or whether signed numbers are in two&#x27;s complement. Even here, the types act to abstract exactly those choices developers want to stop caring about.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;type-systems-share-some-similarities-with-proof-systems&quot;&gt;Type Systems share some Similarities with Proof Systems&lt;&#x2F;h1&gt;
&lt;p&gt;So if it&#x27;s not really about giving sequences of bits meaning, is there a different way to look at types?&lt;&#x2F;p&gt;
&lt;p&gt;While tackling this topic, I&#x27;m hoping that you have some (perhaps partially forgotten) introductory-level knowledge of formal logic. If you’re like me, you may have encountered some propositional logic in your Grade 11 Discrete Mathematics course, or perhaps a few years later in undergraduate philosophy. I&#x27;m not going to lean on it in any in-depth way in this blog, but its a nice building block for understanding type systems and in turn, types.&lt;&#x2F;p&gt;
&lt;p&gt;While I don&#x27;t want to turn this is an introduction to propositional logic, lets take a quick moment to refresh our memories on the two ways you can show that &lt;code&gt;A ∧ B&lt;&#x2F;code&gt; entails &lt;code&gt;B ∧ A&lt;&#x2F;code&gt; in propositional logic.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;semantic-entailment&quot;&gt;Semantic Entailment&lt;&#x2F;h3&gt;
&lt;p&gt;The first way you can show that &lt;code&gt;A ∧ B&lt;&#x2F;code&gt; entails &lt;code&gt;B ∧ A&lt;&#x2F;code&gt; in propositional logic is via a semantic proof. You&#x27;ve probably seen these done via tables (often called &amp;quot;truth tables&amp;quot;) like so:&lt;&#x2F;p&gt;
&lt;table style=&quot;width: auto&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;A&lt;&#x2F;th&gt;
    &lt;th&gt;B&lt;&#x2F;th&gt;
    &lt;th&gt;A ∧ B&lt;&#x2F;th&gt;
    &lt;th&gt;B ∧ A&lt;&#x2F;th&gt;
  &lt;&#x2F;tr&gt;
  &lt;tr&gt;
    &lt;td&gt;T&lt;&#x2F;td&gt;
    &lt;td&gt;T&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;T&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;T&lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;tr&gt;
    &lt;td&gt;T&lt;&#x2F;td&gt;
    &lt;td&gt;F&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;tr&gt;
    &lt;td&gt;F&lt;&#x2F;td&gt;
    &lt;td&gt;T&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;tr&gt;
    &lt;td&gt;F&lt;&#x2F;td&gt;
    &lt;td&gt;F&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
    &lt;td style=&quot;text-align: center&quot;&gt;F&lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
&lt;&#x2F;table&gt;
&lt;p&gt;Implicit in this table is the meaning of &lt;code&gt;A&lt;&#x2F;code&gt; and the meaning of &lt;code&gt;B&lt;&#x2F;code&gt;. To make this explicit, they denote something called a proposition. Semantically, propositions are these objects that can be either &lt;code&gt;T&lt;&#x2F;code&gt; or &lt;code&gt;F&lt;&#x2F;code&gt; (Sometimes read as &lt;em&gt;&amp;quot;true&amp;quot;&lt;&#x2F;em&gt; and &lt;em&gt;&amp;quot;false&amp;quot;&lt;&#x2F;em&gt; respectively). &lt;code&gt;T&lt;&#x2F;code&gt; and &lt;code&gt;F&lt;&#x2F;code&gt; don&#x27;t appear anywhere when we discuss the syntax of propositional logic, they only appear when we ask something like &amp;quot;what does &lt;code&gt;A&lt;&#x2F;code&gt; mean?&amp;quot;&lt;&#x2F;p&gt;
&lt;p&gt;We say that &lt;code&gt;A ∧ B ⊨ B ∧ A&lt;&#x2F;code&gt; because when we ask what &lt;code&gt;A ∧ B&lt;&#x2F;code&gt;, and &lt;code&gt;B ∧ A&lt;&#x2F;code&gt; means, in every instance where &lt;code&gt;A ∧ B&lt;&#x2F;code&gt; is &lt;code&gt;T&lt;&#x2F;code&gt;, &lt;code&gt;B ∧ A&lt;&#x2F;code&gt; is also &lt;code&gt;T&lt;&#x2F;code&gt; (More generally, we can understand &lt;code&gt;⊨&lt;&#x2F;code&gt; here as a relationship between specific rows and columns on a truth table). This is pretty easy in this case because we can exhaustively look at every possibility: All four of them!&lt;&#x2F;p&gt;
&lt;div class=&quot;aside&quot;&gt;&lt;p&gt;Maybe you think the answer to a question like &amp;quot;what does &lt;code&gt;A&lt;&#x2F;code&gt; mean?&amp;quot; should be something like &amp;quot;A stands for &#x27;grass is green&#x27;&amp;quot;. In philosophy, it&#x27;s common to pick linguistic propositions that we can interpret some truth value for instead of picking &lt;code&gt;T&lt;&#x2F;code&gt; or &lt;code&gt;F&lt;&#x2F;code&gt; directly. Either &lt;em&gt;&#x27;it is raining&#x27;&lt;&#x2F;em&gt; or not. Because our interpretations are blind to the difference between &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;em&gt;&#x27;grass is green&#x27;&lt;&#x2F;em&gt;, we&#x27;re avoiding linguistic tricks like &lt;code&gt;A&lt;&#x2F;code&gt; stands for &lt;em&gt;&amp;quot;this proposition is false&amp;quot;&lt;&#x2F;em&gt; or &lt;code&gt;A&lt;&#x2F;code&gt; stands for &lt;em&gt;&amp;quot;Not &lt;code&gt;A&lt;&#x2F;code&gt;&amp;quot;&lt;&#x2F;em&gt; by dint of interpreting only symbols and logical connectives.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;So it turns out that in propositional logic specifically, you can always discover whether &lt;code&gt;A ⊨ B&lt;&#x2F;code&gt; by building a truth table. Building these tables quickly gets tiresome and other logics don’t can’t be exhaustively searched this way, so there’s another way to show this entailment. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;proof-system-entailment&quot;&gt;Proof System Entailment&lt;&#x2F;h3&gt;
&lt;p&gt;The second way you can prove that that &lt;code&gt;A ∧ B&lt;&#x2F;code&gt; entails &lt;code&gt;B ∧ A&lt;&#x2F;code&gt; in propositional logic is via its proof system. &lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m not going to go over proof rules. I&#x27;m assuming that even if you&#x27;ve forgotten the specifics, you remember generally how they were used. Instead, I&#x27;ll ask you to notice that we don&#x27;t contend with &lt;code&gt;T&lt;&#x2F;code&gt; or &lt;code&gt;F&lt;&#x2F;code&gt; at all while using a proof system. This is because the end-game of a proof system is to cleverly pick rules that only let you assume something to denote &lt;code&gt;T&lt;&#x2F;code&gt; &lt;strong&gt;or&lt;&#x2F;strong&gt; to write something that must denote &lt;code&gt;T&lt;&#x2F;code&gt;. If you somehow convincingly manage the feat of picking your rules this way, you can magically know what your truth table looks like for every relevant line.&lt;&#x2F;p&gt;
&lt;table style=&quot;width: auto&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt; Line # &lt;&#x2F;th&gt;
    &lt;th&gt; Proof Line &lt;&#x2F;th&gt;
    &lt;th&gt; Proof rule that makes this line legal &lt;&#x2F;th&gt;
  &lt;&#x2F;tr&gt;
    &lt;td&gt; 1. &lt;&#x2F;td&gt;
    &lt;td&gt; A ∧ B &lt;&#x2F;td&gt;
    &lt;td&gt; Assumption &lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;&#x2F;tr&gt;
    &lt;td&gt; 2. &lt;&#x2F;td&gt;
    &lt;td&gt; A &lt;&#x2F;td&gt;
    &lt;td&gt; ∧ elimination on line 1 &lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;&#x2F;tr&gt;
    &lt;td&gt; 3. &lt;&#x2F;td&gt;
    &lt;td&gt; B &lt;&#x2F;td&gt;
    &lt;td&gt; ∧ elimination on line 1 &lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
  &lt;&#x2F;tr&gt;
    &lt;td&gt; 4. &lt;&#x2F;td&gt;
    &lt;td&gt; B ∧ A &lt;&#x2F;td&gt;
    &lt;td&gt; ∧ introduction on line 3 and line 2 &lt;&#x2F;td&gt;
  &lt;&#x2F;tr&gt;
&lt;&#x2F;table&gt;
&lt;p&gt;We say that &lt;code&gt;A ∧ B ⊢ B ∧ A&lt;&#x2F;code&gt; because we have a proof system where if we assume &lt;code&gt;A ∧ B&lt;&#x2F;code&gt;, there exists some number of legal lines after which we can legally write &lt;code&gt;B ∧ A&lt;&#x2F;code&gt;. We can understand &lt;code&gt;⊢&lt;&#x2F;code&gt; as a purely syntactic game because we never need to reference &lt;code&gt;T&lt;&#x2F;code&gt;, or &lt;code&gt;F&lt;&#x2F;code&gt;, or tables or any such thing. This becomes an interesting game to us because we&#x27;ve designed it so that it can only generate propositions for which &lt;code&gt;⊨&lt;&#x2F;code&gt; also holds. We have a term for this relationship. Having this property where &lt;code&gt;A ⊢ B&lt;&#x2F;code&gt; entails &lt;code&gt;A ⊨ B&lt;&#x2F;code&gt; makes a proof system &lt;span class=pink-emph&gt;sound&lt;&#x2F;span&gt;. (Perhaps less interestingly; for propositional logic it is also the case that &lt;code&gt;A ⊨ B&lt;&#x2F;code&gt; entails &lt;code&gt;A ⊢ B&lt;&#x2F;code&gt;, which makes propositional logic’s proof system &lt;span class=pink-emph&gt;complete&lt;&#x2F;span&gt;). &lt;&#x2F;p&gt;
&lt;h3 id=&quot;propositional-proofs-in-general&quot;&gt;Propositional Proofs in General&lt;&#x2F;h3&gt;
&lt;p&gt;In propositional logic, the proof system approach is often a much more concise way to show an entailment. For example, &lt;code&gt;A ∧ B ∧ C ∧ D ∧ E ⊨ B ∧ C ∧ D ∧ E ∧ A&lt;&#x2F;code&gt; takes a 32-line truth table, while &lt;code&gt;A ∧ B ∧ C ∧ D ∧ E ⊢ B ∧ C ∧ D ∧ E ∧ A&lt;&#x2F;code&gt; takes a 4-line proof (It’s a twin to the 4-line proof from above where &lt;code&gt;B ∧ C ∧ D ∧ E&lt;&#x2F;code&gt; replaces &lt;code&gt;B&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The other cool property of a proof system is that as long as we agree to the same rules, anybody can check a proof and confirm that the rules have been followed. The idea that &amp;quot;there&#x27;s no special intuition required, anybody can mechanistically check the rules&amp;quot; is what ends up making proofs written in a proof system machine checkable. You can write a program that can check the correctness of any proof.&lt;&#x2F;p&gt;
&lt;p&gt;So even in logics where you cannot &amp;quot;write out the truth table,&amp;quot; and for which there&#x27;s no way to know when to stop searching for a proof... at least you can rest assured that if you ever do find a proof, you and others can certainly verify that the proof is correct.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;type-systems&quot;&gt;Type Systems&lt;&#x2F;h3&gt;
&lt;p&gt;So what does all this propositional logic have to do with Type Systems and with Types? &lt;&#x2F;p&gt;
&lt;p&gt;Well, type systems and proof systems have a lot of similar properties. They both have a clean separation of syntax and semantics, they both offer a purely syntactic set of rules, that anybody (even a program) can check. They both value the relationship between &lt;code&gt;⊢&lt;&#x2F;code&gt; and &lt;code&gt;⊨&lt;&#x2F;code&gt; so that the rules for what you can do syntactically translate well into the semantics (Few programming languages actually boast a properly sound type system, though they do still value making the distinction as clear as possible).&lt;&#x2F;p&gt;
&lt;p&gt;Where the proof system above is just there to enforce tautologies, type systems exist to enforce abstractions. Specifically to do so in a machine tractable way. What does that even mean? &lt;&#x2F;p&gt;
&lt;p&gt;It sort of hard to go into detail without picking a specific type system, but we&#x27;re going to pivit first. Lets get back to propositions so we can talk about about Types themselves.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;what-are-propositions-in-propositional-logic&quot;&gt;What are Propositions in Propositional Logic?&lt;&#x2F;h1&gt;
&lt;p&gt;We&#x27;re going to keep coming back to the mathematical substrate I was familiar with before types. It&#x27;s how I started to build intuitions on the topic, but more importantly for this blog the idea that types and propositions are related is a deeply researched topic. We&#x27;ll benefit from scratching the surface a bit. I&#x27;d like to take a quick detour into what a proposition is because talking about the meaning of things which themselves might denote meaning is more difficult than it first appears.&lt;&#x2F;p&gt;
&lt;p&gt;So when I open my undergrad textbook, the definition of a proposition in propositional logic is as follows:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A proposition is a statement that can be either &lt;span class=pink-emph&gt;true&lt;&#x2F;span&gt; or &lt;span class=pink-emph&gt;false&lt;&#x2F;span&gt;; it must be one or the other, and it cannot be both.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;To help buttress this definition, I may give some examples of statements which are or are not propositions.&lt;&#x2F;p&gt;
&lt;p&gt;The following are propositions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The reactor is on.&lt;&#x2F;li&gt;
&lt;li&gt;The wing-flaps are up.&lt;&#x2F;li&gt;
&lt;li&gt;John Major is prime minister.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;whereas the following are not:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Are you going out somewhere?&lt;&#x2F;li&gt;
&lt;li&gt;2 + 3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This definition leans on a lot of other definitions and intuitions that don&#x27;t actually surface in propositional logic at all. For starters, you&#x27;d be excused for thinking propositions are linguistic expressions, but philosophically the English sentence &amp;quot;Snow is white&amp;quot; denotes the same proposition as the German sentence &amp;quot;Schnee ist weiß&amp;quot; even though the two sentences are not the same. A more nuanced definition may say something about propositions being &amp;quot;the sort of thing that declarative sentences denote&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;This is all rather abstract and you can write a PhD Thesis on how linguistic expressions do&#x2F;have embedded and deviate from formal logic. That sends us down the wrong rabbit whole for our purposes. Really, propositions in propositional logic are the building blocks of a sort of syntactic game that gets interesting and applicable once you imbue it with meaning.&lt;&#x2F;p&gt;
&lt;p&gt;Syntactically, there are a set of base propositions. For example the elements of &lt;code&gt;{P, Q, R}&lt;&#x2F;code&gt; are propositions because we&#x27;ve defined them to be. Then there are a small set of logical connectives and rules for how they&#x27;re to be used to juxtapose propositions. So the elements of &lt;code&gt;{¬, ∧, ∨, →, ↔}&lt;&#x2F;code&gt; are logical connectives. I won&#x27;t spell out the rules for how to determine a well-formed formula. For example: &lt;code&gt;P → Q&lt;&#x2F;code&gt;, &lt;code&gt;P → ¬Q&lt;&#x2F;code&gt;, and &lt;code&gt;P ∨ ¬P&lt;&#x2F;code&gt; are all well formed but &lt;code&gt;P Q ∧&lt;&#x2F;code&gt;, &lt;code&gt;P ∧ ∧ Q&lt;&#x2F;code&gt;, and &lt;code&gt;¬∧P&lt;&#x2F;code&gt; are all not well formed. Then we perform the neat trick of saying that any well formed formula is definitionally a proposition.&lt;&#x2F;p&gt;
&lt;p&gt;So assuming you learned the rules for a well-formed formula and you&#x27;re armed with a set potentially infinite base propositions, you can simply say that propositional logic propositions are exactly these things. In a sense you can stop here. There are infinitely many of them, but you can create and verify every possible proposition and that&#x27;s the end of it. You&#x27;ve answered the question: &amp;quot;What are Propositions in Propositional Logic?&amp;quot; as best as it can be answered.&lt;&#x2F;p&gt;
&lt;p&gt;What comes next, the &amp;quot;giving them meaning&amp;quot; part can be done in any number of ways. Most of the semantics we &lt;strong&gt;could&lt;&#x2F;strong&gt; give this system serve no purpose. For example, I can get outright silly with it and say something like &amp;quot;all propositions denote my left pinky finger&amp;quot;. I make the syntactic game above somewhat silly because no matter how I puzzle together big complex propositions, all they&#x27;ll ever do is denote my left pinky finger. That&#x27;s not helpful.&lt;&#x2F;p&gt;
&lt;p&gt;So instead, let me quote Wikipedia:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;propositions are often modeled as functions which map a possible world to a truth value. For instance, the proposition that the sky is blue can be modeled as a function which would return the truth value &lt;span class=pink-emph&gt;T&lt;&#x2F;span&gt; if given the actual world as input, but would return &lt;span class=pink-emph&gt;F&lt;&#x2F;span&gt; if given some alternate world where the sky is green. &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proposition&quot;&gt;Wikipedia &lt;sup&gt;(link)&lt;&#x2F;sup&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Such functions deterministically tell us how to interpret any proposition as &lt;span class=pink-emph&gt;T&lt;&#x2F;span&gt; or &lt;span class=pink-emph&gt;F&lt;&#x2F;span&gt;. If they interpret the logical connectives properly, they imbue the entire enterprise with a structured meaning that is interesting by design.&lt;&#x2F;p&gt;
&lt;div class=&quot;aside&quot;&gt;&lt;p&gt;Two quick notes on the side:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;If you view &lt;strong&gt;T&lt;&#x2F;strong&gt; as the singleton set and &lt;strong&gt;F&lt;&#x2F;strong&gt; as the empty set, you can see the standard set theoretic semantics of propositional logic as a generalization of this semantic interpretation of predicate logic. So you can define the logical connectives above using truth tables (in the style I used earlier) or you can define them as set operations like unions, intersections and such. The approaches are the same (up to isomorphism).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;I&#x27;m writting a post which models the semantics of propositions in Lambda Calculus using JavaScript you can easily run in your browser. I&#x27;ll link it here. It&#x27;s a completely useless excersize for day-to-day programming, but it completely amazed me and I hope it does the same for you.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;div&gt;&lt;h1 id=&quot;about-types&quot;&gt;About Types&lt;&#x2F;h1&gt;
&lt;p&gt;Types are a syntactic tool for abstraction and can be talked about purely as a way to add structure to the question of whether some piece of syntax is well formed.&lt;&#x2F;p&gt;
&lt;p&gt;Typically a type theory will have a few base types and then a few type-forming rules. Then types are straightforwardly defined as the (potentially infinite) hierarchy of types that can be generated. This is defining types by just looking at the syntactic game that creates them — seem familiar?.&lt;&#x2F;p&gt;
&lt;p&gt;So really, what&#x27;s the point of the syntactic type game loosely described above? Types as they&#x27;re discussed in the more advanced type theory circles have a direct categorical semantics. As friend of mine jokingly says, &amp;quot;category theory is general abstract nonsense&amp;quot; (based on how prominent representatives of the mathematical community reacted to its introduction), so we&#x27;re going to shy away from that for the moment.&lt;&#x2F;p&gt;
&lt;p&gt;A way to model the semantics of types of a simple type theory is as sets of values. To quote:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Types” denote nonempty sets of values; they are used to restrict the scope of variables, control the formation of expressions, and classify expressions by their values. &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;William M. Farmer &lt;sup&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;imps.mcmaster.ca&#x2F;doc&#x2F;seven-virtues.pdf&quot;&gt;(link)&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;When you open a Java Class file and see:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Java&quot; class=&quot;language-Java z-code&quot;&gt;&lt;code class=&quot;language-Java&quot; data-lang=&quot;Java&quot;&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-storage z-type z-primitive z-java&quot;&gt;int&lt;&#x2F;span&gt; a &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-java&quot;&gt;5&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or a Rust file and see:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; class=&quot;language-Rust z-code&quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span class=&quot;z-source z-rust&quot;&gt;&lt;span class=&quot;z-storage z-type z-rust&quot;&gt;let&lt;&#x2F;span&gt; a&lt;span class=&quot;z-punctuation z-separator z-rust&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-type z-rust&quot;&gt;i32&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-rust&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-rust&quot;&gt;5&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-rust&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt; and &lt;span class=blue-emph&gt;i32&lt;&#x2F;span&gt; are types and in this case and both denote a &lt;span class=blue-emph&gt;32-bit signed two&#x27;s complement integer&lt;&#x2F;span&gt;. The variable &lt;code&gt;a&lt;&#x2F;code&gt; is restricted in scope to exactly one of &lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt;&#x27;s 2&lt;sup&gt;32&lt;&#x2F;sup&gt; (or 4294967296) possible inhabitants. There&#x27;s some loose notion under which &lt;code&gt;a&lt;&#x2F;code&gt; denotes an element of &lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt; as though &lt;span class=blue-emph&gt;int&lt;&#x2F;span&gt; is a set. If I had written &lt;code&gt;int a = 5.3,&lt;&#x2F;code&gt; I would have received a compilation error saying the expression is not well typed. The error would say something to the effect there&#x27;s no meaningful way to assign a floating point number to a variable meant to hold an integer.&lt;&#x2F;p&gt;
&lt;p&gt;Type systems and type theories use types as a syntactic tool for abstraction, but they don&#x27;t need to be so embedded to be useful. Consider Hungarian notation, which is an identifier naming convention that prefaces variable names with their data type. For example, the &lt;span class=pink-emph&gt;b&lt;&#x2F;span&gt; prefacing &lt;span class=pink-emph&gt;bBusy&lt;&#x2F;span&gt; denotes a &lt;span class=blue-emph&gt;boolean&lt;&#x2F;span&gt; and &lt;span class=pink-emph&gt;nSize&lt;&#x2F;span&gt; is an &lt;span class=blue-emph&gt;integer&lt;&#x2F;span&gt;. This was popularized in a language called BCPL because BCPL has no data types other than the machine word, nothing in the language itself helps a programmer remember variables&#x27; types. &lt;&#x2F;p&gt;
&lt;p&gt;Other untyped languages hold such information in the comments or through other conventions. It&#x27;s important to note that just like assembly or BCPL still have types in the margins, typed languages also continue that trend. Developers can and do use the type &lt;span class=blue-emph&gt;integer&lt;&#x2F;span&gt; as a bit-field or the type &lt;span class=blue-emph&gt;string&lt;&#x2F;span&gt; as tags to approximate a disjoint union. Just consider that you can write a Haskell program that only uses values of type &lt;span class=blue-emph&gt;SequenceOfBits&lt;&#x2F;span&gt; (allowing a wrapper around the std library) to create most any program you&#x27;d like, though I imagine you&#x27;d have a hard time doing so without making many many many mistakes along the way.&lt;&#x2F;p&gt;
&lt;p&gt;At their core, types seem like a very simple, but frustratingly abstract thing. They have a somewhat liminal nature, existing in many forms directly in syntax — where rules inductively define well typed syntax — and also in the meta-language — where we leave it as an exercise to the reader to understand why some expressible syntax is not necessarily meaningful.&lt;&#x2F;p&gt;
&lt;p&gt;For example, Rust&#x27;s type system infers every variable below to be an &lt;span class=blue-emph&gt;i32&lt;&#x2F;span&gt;. If I were writing a chair-based library for millions of developers to use, I would probably employ Rust&#x27;s type system to ensure such code never compiles. If I&#x27;m writing a quick script, I may just stick with &lt;span class=blue-emph&gt;i32&lt;&#x2F;span&gt; and be careful about what I write.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust z-code&quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;z-source z-rust&quot;&gt;&lt;span class=&quot;z-storage z-type z-rust&quot;&gt;let&lt;&#x2F;span&gt; chair_colour &lt;span class=&quot;z-keyword z-operator z-assignment z-rust&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-rust&quot;&gt;15761536&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-rust&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-rust&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; #F08080 HTML standard Hex colour code
&lt;&#x2F;span&gt;&lt;span class=&quot;z-storage z-type z-rust&quot;&gt;let&lt;&#x2F;span&gt; chair_height &lt;span class=&quot;z-keyword z-operator z-assignment z-rust&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-rust&quot;&gt;458&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-rust&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-rust&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; millimetres
&lt;&#x2F;span&gt;
&lt;span class=&quot;z-comment z-line z-double-slash z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-rust&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; The following is almost certainly a bug
&lt;&#x2F;span&gt;&lt;span class=&quot;z-storage z-type z-rust&quot;&gt;let&lt;&#x2F;span&gt; syntactically_legal_nonsense &lt;span class=&quot;z-keyword z-operator z-assignment z-rust&quot;&gt;=&lt;&#x2F;span&gt; chair_colour &lt;span class=&quot;z-keyword z-operator z-arithmetic z-rust&quot;&gt;+&lt;&#x2F;span&gt; chair_height&lt;span class=&quot;z-punctuation z-terminator z-rust&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;a-more-nuanced-view-on-types&quot;&gt;A More Nuanced View on Types&lt;&#x2F;h1&gt;
&lt;p&gt;To develop a nuanced view of what types you need to understand them in the context of how and why they&#x27;re used. What motivates the use of types? When we look at the ways in which they&#x27;re used in older imperative programming languages, a simple answer might be &amp;quot;so that the compiler can calculate how much memory some data takes and how to represent (persist) the data in memory so that I don&#x27;t have to do it myself&amp;quot;. To support this line of reasoning, these languages always give you a way to build more complex types from simpler types. Lets run with an example, most languages allow you to define a new product type called a pair from any other two types: &lt;code&gt;∀ A:type B:type | (A, B):type&lt;&#x2F;code&gt;. This reads &amp;quot;The pairing of any two types is itself a type&amp;quot;. A use for this is that the compiler can understand how a type can be represented based on its construction. How a pair is persisted in memory depends on the types in question, but you can describe what to do generically. For each way you can build up more complex types (like &lt;code&gt;∀ A:type | [A]:type&lt;&#x2F;code&gt;, or &lt;code&gt;∀ A:type | Vec&amp;lt;A&amp;gt;:type&lt;&#x2F;code&gt;), you can equip the compiler with rules that let it understand what to do. So the compilor contains something akin to a function from types to memory layout, but just like you can create new proposition using the logical connectives, you can create new types using some given connectives.&lt;&#x2F;p&gt;
&lt;p&gt;It turns out that we want the rules for how to persist a type in memory to have some predictable mathimatical structure. Like if we want to let the compilor optimise memory layouts, we need to feed it rules for how types can be re-written. Why should we allow the following re-write:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Point {
  x: Int,
  y: Int
}
GameNode {
  tag: String,
  parent: Point,
  pos: Point
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;to&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;GameNode {
  tag: String,
  parent_x: Int,
  parent_y: Int,
  pos_x: Int,
  pos_y: Int
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or even&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;GameNode (String, Int, Int, Int, Int)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There&#x27;s a deeper structure here, because just like predicates and propositions become useful in the context of a logic that declares how they can be juxtaposed with various operators (syntax) and a model for how to evaluate any legal syntax to it&#x27;s meaning (semantics). Types become useful in the context of a theory that declares how they can be juxtaposed with various operators (syntax) and a model for how to evaluate any legal syntax to it&#x27;s meaning (semantics). You&#x27;re abstracting something more interesting than &amp;quot;memory layout&amp;quot; when you build types and let the compiler figure out the rest. You&#x27;re actually annotating your program with a system that has a structure you can hijack for your own means to enforce program-wide properties. &lt;&#x2F;p&gt;
&lt;p&gt;I don&#x27;t think the following is necessary to develop a deeper understanding of types, but if you&#x27;ve taken a course or done some reading on &lt;span class=pink-emph&gt;first-order logic&lt;&#x2F;span&gt;, then I recommend perusing &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;imps.mcmaster.ca&#x2F;doc&#x2F;seven-virtues.pdf&quot;&gt;this paper (link)&lt;&#x2F;a&gt;. It&#x27;s a paper that hopes to recommend teaching a simplified type theory to undergrads. Assuming you have a bit of background with first-order logic, the paper is very accessible. A highlight is where it shows that although simple type theory has none of the propositional connectives or quantifiers, they can all be easily defined in simple type theory using function application, function abstraction, and equality. I&#x27;ll let the paper speak for itself, but to me the power of Simple Type Theory is that is has a very uniform syntax, but hidden within a hierarchy of types is the full power of higher-order predicate logic.&lt;&#x2F;p&gt;
&lt;p&gt;The theory presented in the paper is type theory boiled down to its essence. It is convenient for study, but it is not highly practical for use. This is where extensions to the theory and macro-expansions and such pick up the slack.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;in-conclusion&quot;&gt;In Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;The thing to consider then, is that when a computer scientist is using &lt;span class=blue-emph&gt;Int&lt;&#x2F;span&gt; to label a variable, they can be seen as abstracting away the representation of an &lt;span class=blue-emph&gt;Int&lt;&#x2F;span&gt;&#x27;s value as a series of bits, or as annotating their program with something akin to a logic. What&#x27;s been done when annotating a variable with an &lt;span class=pink-emph&gt;Int&lt;&#x2F;span&gt; is very simple, but as you build complex types from simpler types and construct tuples, lists, sets, etc you&#x27;re building up more complex logical expressions that let you abstract away the representation of increasingly complex data. You can use function abstraction to view programs themselves as sequences of bits that need abstracting. This lets a developer create boundaries across which the way in which entire parts of your program are represented is abstracted.&lt;&#x2F;p&gt;
&lt;p&gt;In functional programming languages with relatively expressive type systems, it&#x27;s very common to see the sorts of choices made in imperative languages being encoded as types instead. That way instead of writing out &lt;code&gt;if, else if, else&lt;&#x2F;code&gt; statements, you generate a value of some type and by cleverly encoding how these types are allowed to be composed, you&#x27;re on you way to ensuring certain bad sequences of choices (now types) are not possible to create without a type error. Carefully crafting and letting a type system enforce such invariants for you matters more as software size, number of developers, and magnitude of maintenance increases.&lt;&#x2F;p&gt;
&lt;p&gt;At a minimum you&#x27;re adding a logic system that sits on-top of your program and describes some part of it (for example: Java, C#, TypeScript, Go, etc). At the extreme end, you&#x27;ve realized the depths of the &lt;span class=pink-emph&gt;Curry–Howard Correspondence&lt;&#x2F;span&gt; and you&#x27;re a developer writing executable math proofs (for example: Idris, Agda, Coq, Lean, etc).&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
